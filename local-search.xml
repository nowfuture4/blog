<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Git</title>
    <link href="/2023/01/13/git/"/>
    <url>/2023/01/13/git/</url>
    
    <content type="html"><![CDATA[<h1 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h1><h2 id="git安装"><a href="#git安装" class="headerlink" title="git安装"></a>git安装</h2><h3 id="在-Linux-上安装"><a href="#在-Linux-上安装" class="headerlink" title="在 Linux 上安装"></a>在 Linux 上安装</h3><ul><li>Centos(无维护):<code>sudo dnf install git-all </code></li><li>Debian:<code>sudo apt install git-all</code></li></ul><h3 id="在-Windows-上安装"><a href="#在-Windows-上安装" class="headerlink" title="在 Windows 上安装"></a>在 Windows 上安装</h3><ul><li>直接下载安装文件，别下载压缩包，压缩包没环境</li><li>源文件安装，比较麻烦，有必要就按需安装</li></ul><h2 id="初次运行git前的配置"><a href="#初次运行git前的配置" class="headerlink" title="初次运行git前的配置"></a>初次运行git前的配置</h2><h3 id="用户信息"><a href="#用户信息" class="headerlink" title="用户信息"></a>用户信息</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">git config --<span class="hljs-variable language_">global</span> user.<span class="hljs-property">name</span> <span class="hljs-string">&quot;John Doe&quot;</span><br>git config --<span class="hljs-variable language_">global</span> user.<span class="hljs-property">email</span> <span class="hljs-string">&quot;johndoe@example.com&quot;</span><br></code></pre></td></tr></table></figure><h2 id="获取帮助"><a href="#获取帮助" class="headerlink" title="获取帮助"></a>获取帮助</h2><p>对于不清楚的命令直接帮助搜索就好了：<code>git help &lt;verb&gt;</code></p><h2 id="git基础"><a href="#git基础" class="headerlink" title="git基础"></a>git基础</h2><h3 id="获取git仓库"><a href="#获取git仓库" class="headerlink" title="获取git仓库"></a>获取git仓库</h3><blockquote><ol><li>将尚未进行版本控制的本地目录转换为 Git 仓库。</li><li>从其它服务器 克隆 一个已存在的 Git 仓库。</li></ol></blockquote><ol><li>在已存在目录中初始化仓库</li></ol>  <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//在 Linux 上：</span><br>cd /home/user/my_project<br><span class="hljs-comment">//在 macOS 上：</span><br>cd /<span class="hljs-title class_">Users</span>/user/my_project<br><span class="hljs-comment">//在 Windows 上：</span><br>cd /c/user/my_project<br><span class="hljs-comment">//之后执行：</span><br>git init<br><br><span class="hljs-comment">//跟踪文件</span><br>git add *.<span class="hljs-property">c</span><br>git add <span class="hljs-variable constant_">LICENSE</span><br>git commit -m <span class="hljs-string">&#x27;initial project version&#x27;</span><br></code></pre></td></tr></table></figure><ol start="2"><li>克隆现有的仓库<br><code>git clone https://</code></li></ol><h3 id="记录跟新"><a href="#记录跟新" class="headerlink" title="记录跟新"></a>记录跟新</h3><p>文件追踪流程：未追踪&#x3D;&gt;暂存状态；未修改状态&#x3D;&gt;修改状态&#x3D;&gt;暂存状态；暂存状态&#x3D;&gt;提交之后就会回到未修改状态，同时会删除未追踪的文件，更新为提交版本的文件了,这就是一个完整的文件循环流程。即像竹子一样节节高升，平稳推进。</p><ol><li><p>跟踪新文件：<code>git add xxxx.js </code> <code>git add .</code>;</p></li><li><p>查看状态：<code>git status</code></p></li><li><p>忽略文件，特别是依赖包和一些工具测试文件：创建.gitignore文件</p><ul><li>.gitignore 的格式规范如下：</li><li>所有空行或者以 # 开头的行都会被 Git 忽略。</li><li>可以使用标准的 glob 模式匹配，它会递归地应用在整个工作区中。</li><li>匹配模式可以以（&#x2F;）开头防止递归。</li><li>匹配模式可以以（&#x2F;）结尾指定目录。</li><li>要忽略指定模式以外的文件或目录，可以在模式前加上叹号（!）取反。</li></ul> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//忽略所有的 .a 文件</span><br>*.<span class="hljs-property">a</span><br><span class="hljs-comment">//但跟踪所有的 lib.a，即便你在前面忽略了 .a 文件</span><br>!lib.<span class="hljs-property">a</span><br><span class="hljs-comment">//只忽略当前目录下的 TODO 文件，而不忽略 subdir/TODO</span><br>/<span class="hljs-variable constant_">TODO</span><br><span class="hljs-comment">//忽略任何目录下名为 build 的文件夹</span><br>build/<br><span class="hljs-comment">//忽略 doc/notes.txt，但不忽略 doc/server/arch.txt</span><br>doc<span class="hljs-comment">/*.txt</span><br><span class="hljs-comment">//忽略 doc/ 目录及其所有子目录下的 .pdf 文件</span><br><span class="hljs-comment">doc/**/</span>*.<span class="hljs-property">pdf</span><br></code></pre></td></tr></table></figure></li><li><p>查看已暂存和未暂存的修改</p><ol><li><code>git diff</code></li><li><code>git diff --staged</code> 暂存</li></ol></li><li><p>提交更新：<code>git commit -m &quot;xxx&quot;</code></p></li><li><p>移除文件: <code>git rm fileName</code></p></li><li><p>移动文件：<code>git mv file_from file_to</code></p></li></ol><h3 id="查看提交历史"><a href="#查看提交历史" class="headerlink" title="查看提交历史"></a>查看提交历史</h3><ol><li><code>git log</code></li><li><code>git log -p -2</code>;最近两次提交按照补丁patch格式显示</li><li><code>git log -stat</code>;进行代码审核，查看变化很有用；</li></ol><h3 id="撤销操作"><a href="#撤销操作" class="headerlink" title="撤销操作"></a>撤销操作</h3><ol><li><code>git commit --amend</code>  补充文件，重新提交；<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">git commit -m <span class="hljs-string">&#x27;initial commit&#x27;</span><br>git add forgotten_file<br>git commit --amend<br></code></pre></td></tr></table></figure></li><li>取消暂存的文件:<code>git reset HEAD CONTRIBUTING.md </code></li><li>撤销对文件的修改(不建议使用；操作很危险)：<code>git checkout -- CONTRIBUTING.md</code></li></ol><h3 id="远程仓库使用"><a href="#远程仓库使用" class="headerlink" title="远程仓库使用"></a>远程仓库使用</h3><ol><li>查看远程仓库：<ol><li><code>git remote</code></li><li><code>git remote -v</code> 远程仓库使用的git保存的简写与其对应的url</li><li>查看某个远程仓库:<code>git remote show origin</code></li></ol></li><li>添加远程仓库<ol><li><code>git remote add xxx https://</code></li></ol></li><li>从远程仓库中抓取与拉取<ol><li><code>git fetch &lt;remote&gt;</code> 需要手动合并</li><li><code>git pull</code> 自动合并</li></ol></li><li>推送到远程仓库：<code>git push origin master</code></li><li>远程仓库的重命名与移除:<code>git remote rename xxx yyy</code>;<code>git remote remove yyy</code></li></ol><h3 id="打标签"><a href="#打标签" class="headerlink" title="打标签"></a>打标签</h3><ol><li>列出标签：<code>git tag</code> 参数：-l(-list);</li><li>创建标签：<ol><li>附注标签：<code>git tag -a v1.4 -m &quot;my version 1.4&quot;</code>；</li><li>轻量标签：<code>git tag v1.4-lw</code>&#x3D;<code>git tag tagName</code>;</li><li>后期打标签进行版本控制管理：<code>git tag -a v1.2 9fceb02</code></li></ol></li><li>删除标签：<code>git push origin --delete &lt;tagName&gt;</code></li></ol><h3 id="git别名"><a href="#git别名" class="headerlink" title="git别名"></a>git别名</h3><ol><li>通过git config文件设置命令别名</li></ol><h2 id="git分支"><a href="#git分支" class="headerlink" title="git分支"></a>git分支</h2><ol><li>创建分支：<code>git branch branchName</code></li><li>分支切换，注意暂存及时提交：<code>git checkout branchName</code>;</li></ol><h3 id="分支的创建与合并"><a href="#分支的创建与合并" class="headerlink" title="分支的创建与合并"></a>分支的创建与合并</h3><ol><li>新建分支包括hotfix修复上线项目bug：<code>git checkout -b hoxFixBranchName</code></li><li>分支合并:<code>git checkout master</code>,<code>git merge hoxFixBranchName</code>,删除不需要的分支：<code>git branch -d hoxFixBranchName</code></li><li>冲突合并，根据实际更改情况保留，一般在vscode中比较一下然后手动合并；</li></ol><h3 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h3><ol><li>查看分支列表：<code>git branch</code> 参数-v是查看每个分支最后一次提交</li></ol><h3 id="远程分支"><a href="#远程分支" class="headerlink" title="远程分支"></a>远程分支</h3><ol><li>查看远程分支：<code>git remote show &lt;remote&gt;</code></li><li>推送：<code>git push origin hotFixBranch</code></li><li>跟踪分支：<code>git checkout --track origin/hotFixBranch</code></li><li>删除远程分支：<code>git push origin --delete hotFixBranch</code></li></ol><h3 id="变基"><a href="#变基" class="headerlink" title="变基"></a>变基</h3><ol><li>变基：<code>git rebase master</code>;你可以使用 rebase 命令将提交到某一分支上的所有修改都移至另一分支上，就好像“重新播放”一样。</li><li>变基风险：如果提交存在于你的仓库之外，而别人可能基于这些提交进行开发，那么不要执行变基。（简单来讲，未审核代码直接被别人拿来用就有系统性风险）；</li></ol><h2 id="服务器上的git"><a href="#服务器上的git" class="headerlink" title="服务器上的git"></a>服务器上的git</h2><h3 id="在服务器上搭建-Git"><a href="#在服务器上搭建-Git" class="headerlink" title="在服务器上搭建 Git"></a>在服务器上搭建 Git</h3><ol><li>裸仓库：<code>git clone --bare my_project my_project.git</code>;效果相当于：<code>cp -Rf my_project/.git my_project.git</code></li><li>把裸仓库放到服务器上:<ol><li><p>既然你有了裸仓库的副本，剩下要做的就是把裸仓库放到服务器上并设置你的协议。 假设一个域名为 git.example.com 的服务器已经架设好，并可以通过 SSH 连接， 你想把所有的 Git 仓库放在 &#x2F;srv&#x2F;git 目录下。 假设服务器上存在 &#x2F;srv&#x2F;git&#x2F; 目录，你可以通过以下命令复制你的裸仓库来创建一个新仓库：<code>scp -r my_project.git user@git.example.com:/srv/git</code>;</p></li><li><p>此时，其他可通过 SSH 读取此服务器上 &#x2F;srv&#x2F;git 目录的用户，可运行以下命令来克隆你的仓库。<code>git clone user@git.example.com:/srv/git/my_project.git</code></p></li><li><p>如果到该项目目录中运行 git init 命令，并加上 –shared 选项， 那么 Git 会自动修改该仓库目录的组权限为可写。 注意，运行此命令的工程中不会摧毁任何提交、引用等内容。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">ssh user@git.<span class="hljs-property">example</span>.<span class="hljs-property">com</span><br>cd /srv/git/my_project.<span class="hljs-property">git</span><br>git init --bare --shared<br></code></pre></td></tr></table></figure></li></ol></li></ol><h3 id="生成SSH公钥"><a href="#生成SSH公钥" class="headerlink" title="生成SSH公钥"></a>生成SSH公钥</h3><ol><li><p>生成 SSH 公钥：<code>ssh-keygen -o</code></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 查看ssh</span><br>cd ~/.<span class="hljs-property">ssh</span><br>ls<br><span class="hljs-comment">// 直接查看默认路径下的ssh公钥</span><br>cat ~<span class="hljs-regexp">/.ssh/i</span>d_rsa.<span class="hljs-property">pub</span><br></code></pre></td></tr></table></figure></li></ol><h1 id="Git小结"><a href="#Git小结" class="headerlink" title="Git小结"></a>Git小结</h1><ol><li><p>git初始化：<code>git init</code></p></li><li><p>git config配置：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript">git config --<span class="hljs-variable language_">global</span> user.<span class="hljs-property">name</span> <span class="hljs-string">&quot;hzw728@qq.com&quot;</span><br>git config --<span class="hljs-variable language_">global</span> user.<span class="hljs-property">email</span> <span class="hljs-string">&quot;hzw728@qq.com&quot;</span><br></code></pre></td></tr></table></figure></li><li><p>添加到暂存区：<code>git add .</code></p></li><li><p>提交到本地库：<code>git commit -m &quot;fist commit&quot;</code></p></li><li><p>版本穿梭：</p><ol><li>查看提交情况：<code>git status</code></li><li>查看提交日志：<code>git log</code></li><li>查看操作记录：<code>git reflog</code></li><li>head版本回滚：<code>git reset --hard 919a8bc</code></li><li>head版本回滚一次：<code>git reset --hard HEAD^</code></li><li>暂存区重新写注释：<code>git reset --soft HEAD^</code>,<code>git commit -m &quot;new commit&quot;</code></li><li>暂存区版本撤销并且重新生成一次最新记录：<code>git revert HEAD</code></li><li>git reset与git revert的区别:<ol><li>git reset 回退到指定版本，相当于是隐藏了commit-id之后的记录，并且不会产生新的commit-id的记录，如果要推送到远端服务器，需要强制推送-f，强制推送对其他使用你的分支代码会有影响，慎用。</li><li>git revert 回退到指定版本，但是重新生成一条新的commit-id记录，对其他提交记录没有影响，推送到远端服务器直接push就好了。</li></ol></li></ol></li><li><p>分支管理：</p><ol><li>创建分支：<code>git branch branchName</code></li><li>切换分支：<code>git checkout branchName</code></li><li>合并分支：<code>git merge branchName</code></li><li>删除分支：<code>git branch -d branchName</code></li></ol></li><li><p>远程分支管理：</p><ol><li>添加远程分支：<code>git remote add origin https//</code></li><li>查看远端分支：<code>git remote -v</code></li><li>推送到远端分支：<code>git push origin master</code></li><li>记录推送默认远端分支：<code>git push -u origin master</code></li><li>删除远程分支：<code>git push origin --delete hotFixBranch</code>,或者<code>git push origin :hotFixBranch</code></li><li>拉取远端分支：<code>git pull origin dev</code></li></ol></li><li><p>团队开发：</p><ol><li>每天第一件事就是拉取git pull更新一下代码</li><li>下班前提交代码，避免断电导致硬件故障导致本地代码丢失</li></ol></li><li><p>gitignore</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ES6~ES13</title>
    <link href="/2023/01/05/ES6~ES13/"/>
    <url>/2023/01/05/ES6~ES13/</url>
    
    <content type="html"><![CDATA[<h1 id="ES6-ES13"><a href="#ES6-ES13" class="headerlink" title="ES6~ES13"></a>ES6~ES13</h1><h2 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h2><ul><li>let&#x2F;const declare variable</li><li>variable destructuring&#x2F;assignment</li><li>template strings</li><li>String and Number extend</li><li>Array extend</li><li>Object extend</li><li>Function extend</li><li>Symbol</li><li>iterator</li><li>Set</li><li>Map</li><li>Proxy</li><li>Reflect</li><li>Promise</li><li>Generator</li><li>class&#x2F;class extends</li><li>Module</li></ul><h3 id="let-x2F-const"><a href="#let-x2F-const" class="headerlink" title="let&#x2F;const"></a>let&#x2F;const</h3><p>let&#x2F;const features:</p><ul><li>块级作用域</li><li>不允许重复声明变量</li><li>没有变量提升，暂时性死区</li><li>不与顶层对象挂钩（window）<br>let&#x2F;const different features:</li><li>let可以声明不赋值，但是const必须初始化赋值；</li><li>let可以重新赋值，const不行</li><li>const保存的是指针，值还是可以修改；复杂类型obj对象还是可以改变，可以利用Object.freeze(obj),嵌套的数据结构还要递归冻结才能防止复杂类型obj对象改变；</li></ul><h3 id="variable-destructuring-x2F-assignment"><a href="#variable-destructuring-x2F-assignment" class="headerlink" title="variable destructuring&#x2F;assignment"></a>variable destructuring&#x2F;assignment</h3><p>变量结构赋值：</p><ul><li>eg:<code>let &#123;name:name1=xxx1&#125;=&#123;name:xxx&#125;</code></li><li>根据原型链找属性</li><li>undefined不能解构</li><li>适合少量参数的解构，嵌套层数太深看起来也不优雅</li></ul><h3 id="template-strings"><a href="#template-strings" class="headerlink" title="template strings"></a>template strings</h3><p>模板字符串：</p><ul><li>eg:<code>$&#123;&#125;</code></li><li>主要用于字符串拼接</li></ul><h3 id="String-and-Number-extend"><a href="#String-and-Number-extend" class="headerlink" title="String and Number extend"></a>String and Number extend</h3><p>String:</p><ul><li>includes()</li><li>startsWith()</li><li>endsWith()</li><li>repeat()<br>Number:</li><li>二进制八进制写法</li><li>isFinite()</li><li>isNaN()</li><li>isInteger():整数</li><li>Number.EPSILON极小值属性</li><li>Math.trunc() 将数字的小数部分去掉，只保留整数部分</li><li>Math.sign() 函数返回一个数字的符号，指示数字是正数，负数还是零</li></ul><h3 id="Array-extend"><a href="#Array-extend" class="headerlink" title="Array extend"></a>Array extend</h3><ul><li>… 扩展运算符</li><li>Array.from()静态方法从可迭代或类数组对象创建一个新的浅拷贝的数组实例。</li><li>Array.of()方法通过可变数量的参数创建一个新的 Array 实例，而不考虑参数的数量或类型</li><li>Array.prototype.find()&#x2F;findIndex()</li><li>Array.prototype.fill()</li></ul><h3 id="Object-extend"><a href="#Object-extend" class="headerlink" title="Object extend"></a>Object extend</h3><ul><li>… 扩展运算符</li><li>对象简写：属性方法简写</li><li>对象属性：表达式<code>&#123;[a]:&quot;xxxx&quot;&#125;</code></li><li>Object.assign({},obj1,obj2)</li><li>Object.is(a,b) 判断是否相等</li></ul><h3 id="Function-extend"><a href="#Function-extend" class="headerlink" title="Function extend"></a>Function extend</h3><ul><li>参数默认值设置<code>fn(a=0)&#123;&#125;</code></li><li>rest参数剩余参数…res</li><li>name属性即函数名</li><li>箭头函数<ul><li>无法访问arguments，不可作为构造函数使用即无法使用new实例化对象</li><li>没有this,或者说this指向父作用域</li><li>应用：接口请求用箭头函数调整this指向</li></ul></li></ul><h3 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h3><ul><li>唯一性，避免被覆盖</li><li>不能运算，不能被强制转换进行计算</li><li>显示调用toString()</li><li>隐式转换Boolean</li><li>不能使用for in 循环，可以用Reflect.ownKey()返回一个属性键值对数组</li><li>可作为常量</li></ul><h3 id="iterator"><a href="#iterator" class="headerlink" title="iterator"></a>iterator</h3><p>迭代器：</p><ul><li>Symbol.iterator 为每一个对象定义了默认的迭代器。该迭代器可以被 for…of 循环使用。</li><li>适用对象：Array&#x2F;String&#x2F;Set&#x2F;Map&#x2F;arguments对象&#x2F;NodeList对象</li><li>可以在对象中使用自定义属性定义迭代</li><li>迭代器可以实现私有变量功能，避免被外部修改</li><li>扩展运算符也是基于迭代器快速实现数组等复制功能</li><li>arr<a href="">symbol.iterator</a>.next()</li></ul><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><p>Set数据结构：</p><ul><li>去重</li><li>方法：add&#x2F;has&#x2F;delete&#x2F;clear&#x2F;size&#x2F;values&#x2F;entries&#x2F;keys</li><li>数组与集合转化</li></ul><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><p>Map数据结构：</p><ul><li>Object 结构提供了“ 字符串—值” 的对应， Map 结构提供了“ 值—值” 的对应， 是一种更完善的 Hash 结构实现。</li><li>方法跟Set一样</li></ul><h3 id="Proxy"><a href="#Proxy" class="headerlink" title="Proxy"></a>Proxy</h3><p>代理：Proxy对象用于创建一个对象的代理，从而实现基本操作的拦截和自定义（如属性查找、赋值、枚举、函数调用等）。</p><ul><li>没有代理以前利用Object.defineProperty(obj,”data”,<code>&#123;get()&#123;&#125;,set()&#123;&#125;&#125;</code>),proxy代理比它更高级一点</li><li>const p &#x3D; new Proxy(target, handler)</li><li>handler.get()属性读取操作的捕捉器。</li><li>handler.set()属性设置操作的捕捉器。</li><li>proxy本质上属于元编程非破坏性数据劫持，在原对象的基础上进行功能的衍生而不影响原对象，符合松耦合高内聚的设计理念</li></ul><h3 id="Reflect"><a href="#Reflect" class="headerlink" title="Reflect"></a>Reflect</h3><p>反射：Reflect 是一个内置的对象，它提供拦截 JavaScript 操作的方法。这些方法与 proxy handler 的方法相同。Reflect 不是一个函数对象，因此它是不可构造的。</p><ul><li>替代Object上的某些方法</li><li>处理异常错误时不用try&#x2F;catch捕获错误，可以直接判断reflect，返回布尔值；</li><li>命令式行为改变函数行为。eg:Reflect.deleteProperty(obj,”name”)</li><li>配合Proxy</li></ul><h3 id="Promise-es6-es13"><a href="#Promise-es6-es13" class="headerlink" title="Promise (es6~es13)"></a>Promise (es6~es13)</h3><p>Promise 对象用于表示一个异步操作的最终完成（或失败）及其结果值。</p><ul><li>pending 待定;fulfilled:resolved;rejected:rejected;</li><li>返回Promise对象</li><li>链式调用</li><li>静态方法：(自身迭代iterable)<ul><li>promise.all(iterable)</li><li>promise.allSettled(iterable)</li><li>promise.any(iterable)</li><li>promise.race(iterable)</li><li>promise.reject(reason)</li><li>promise.resolve(value)</li></ul></li><li>实例方法：<ul><li>promise.then()</li><li>promise.catch()</li><li>promise.finally()</li></ul></li></ul><h3 id="Generator"><a href="#Generator" class="headerlink" title="Generator"></a>Generator</h3><p>es6提供的一种异步编程解决方案（手动版async&#x2F;await）</p><ul><li>状态机。封装了多个内部状态</li><li>执行generator函数会返回一个遍历器对象，可以依次遍历generator函数内部的每一个状态</li><li>基本语法：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span>* <span class="hljs-title function_">fnName</span>(<span class="hljs-params"></span>)&#123;&#125;<br><span class="hljs-keyword">function</span> *<span class="hljs-title function_">fnName</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">yield</span> index++;<br>    <span class="hljs-keyword">yield</span> <span class="hljs-string">&quot;xxx&quot;</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;cc&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li>实例方法：<ul><li>next()</li><li>return()</li><li>throw()</li></ul></li><li>流程调度方案</li></ul><h3 id="class-x2F-class-extends"><a href="#class-x2F-class-extends" class="headerlink" title="class&#x2F;class extends"></a>class&#x2F;class extends</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">Human</span>&#123;<br>  <span class="hljs-comment">//公有字段</span><br>  height = <span class="hljs-number">0</span>;<br>  width;<br>  <span class="hljs-comment">//私有字段</span><br>  #height = <span class="hljs-number">0</span>;<br>  #width;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">name, age</span>)&#123;<br>      <span class="hljs-comment">//super调用父级对象上的属性和方法</span><br>      <span class="hljs-variable language_">super</span>(name,age);<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span>=name;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">age</span>=age;<br>  &#125;<br>  <span class="hljs-comment">//静态声明</span><br>  <span class="hljs-keyword">static</span> myName=<span class="hljs-string">&quot;person&quot;</span>;<br>  <span class="hljs-keyword">static</span> myMethod=<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br><br>  &#125;<br>  <span class="hljs-comment">//内部方法</span><br>  <span class="hljs-keyword">get</span> <span class="hljs-title function_">location</span>()&#123;&#125;<br>  <span class="hljs-keyword">set</span> <span class="hljs-title function_">location</span>()&#123;&#125;<br><br>&#125;<br><span class="hljs-keyword">const</span> personOne=<span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&quot;xxx&quot;</span>, <span class="hljs-number">10</span>);<br></code></pre></td></tr></table></figure><h3 id="Module"><a href="#Module" class="headerlink" title="Module"></a>Module</h3><p>features:</p><ul><li>异步加载</li><li>私密不漏</li><li>重名不怕</li><li>依赖不乱<br>两种导入导出方式：</li><li>import {A1，A2} from “xxx.js”; export {A1，A2};</li><li>import A1X from “xxx.js”; export default A1;<br>Node.js中的模块化：</li><li>导入导出方式：const obj.A1&#x3D;require.(“xxx.js”);module.export&#x3D;{A1};</li><li>javascript es6与node.js环境中的模块化有所不同，导入导出方式就能看出。</li><li>node.js&#x3D;&gt;es6模块化转化方法<ul><li>第一种：npm init 生成package.json</li><li>第二种：将js文件格式改成mjs</li></ul></li></ul><h2 id="ES7"><a href="#ES7" class="headerlink" title="ES7"></a>ES7</h2><ul><li>exponentiation operator<ul><li>求幂运算符：**</li><li>eg:<code>Math.pow(3,2)===3**2;</code></li></ul></li><li>Array.prototype.includes()<ul><li><code>arr.includes(searchElement, fromIndex)</code></li></ul></li></ul><h2 id="ES8"><a href="#ES8" class="headerlink" title="ES8"></a>ES8</h2><ul><li><p>async&#x2F;await：异步的终极解决方案</p></li><li><p>object extend</p><ul><li>Object.values(obj)：<code>Object.values(&#123;a: 1, b: 2, c: 3&#125;); // [1, 2, 3]</code></li><li>Object.entries(obj):把对象属性序列化放在数组中，键值对；</li><li>Object.getOwnPropertyDescriptors(obj):获取对象属性用于克隆对象（深复制）&#x3D;》Object.defineProperties(obj1,Object.getOwnPropertyDescriptors(obj))</li><li>object.assign(obj1,obj)(浅复制)</li><li>浅复制只是增加一个指针指向已经存在的内存对象，深复制则是增加一个指针和申请新的内存。</li></ul></li><li><p>string extend</p><ul><li>str.padStart(10,”x”):从头开始填充，但字符串长度为10，填满为止</li><li>str.padEnd(10,”x”)</li></ul></li><li><p>function extend</p><ul><li><code>function person( name, age, sex, ) &#123;&#125;</code>参数结尾可以为逗号</li></ul></li></ul><h2 id="ES9"><a href="#ES9" class="headerlink" title="ES9"></a>ES9</h2><ul><li>rest and spread operator (…)：对象的（展开&#x2F;剩余）运算符</li><li>promise.finally()：then().catch().finally()</li><li>async&#x2F;for await：异步迭代，串联单线程，并非并发，队列请求</li></ul><h2 id="ES10"><a href="#ES10" class="headerlink" title="ES10"></a>ES10</h2><ul><li>object.fromEntries()<ul><li>它接收一个键值对列表（Map实例），并返回一个真实对象，其属性由条目给出</li><li>eg:<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> entries = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Map</span>(<br>    [<span class="hljs-string">&quot;apple&quot;</span>,<span class="hljs-string">&quot;orange&quot;</span>],<br>    [<span class="hljs-string">&quot;grapes&quot;</span>, <span class="hljs-string">&quot;peach&quot;</span>]<br>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">fromEntries</span>(entries)) <br><span class="hljs-comment">//  &#123; apple: &quot;origin&quot;, grapes: &quot;peach&quot; &#125;</span><br><br><span class="hljs-keyword">let</span> str=<span class="hljs-string">`name=xiaoming&amp;age=18`</span>;<br><span class="hljs-keyword">let</span> s=<span class="hljs-keyword">new</span> <span class="hljs-title class_">URLSearchParams</span>(str);<br><span class="hljs-keyword">let</span> o=<span class="hljs-title class_">Object</span>.<span class="hljs-title function_">fromEntries</span>(s);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(o);<br><span class="hljs-comment">//&#123;name: &#x27;xiaoming&#x27;, age: &#x27;18&#x27;&#125;</span><br></code></pre></td></tr></table></figure></li></ul></li><li>Array.prototype.flatMap()&#x2F;flat():数组扁平化，传入扁平化深度参数，默认深度为1，将嵌套的深层数组根据需求展开扁平化形成一个低维数组</li><li>String.prototype.trimStart()&#x2F;trimEnd():删除字符串首尾空格</li><li>symbol(“descriptions”)</li><li>try&#x2F;catch:catch的参数有时候是多余的，现在可以省略</li></ul><h2 id="ES11"><a href="#ES11" class="headerlink" title="ES11"></a>ES11</h2><ul><li><p>promise.allSettled():all()的升级版本</p></li><li><p>module extend(dynamic import)：</p><ul><li>通过import声明引用的所有模块（包括初始化暂时用不到的模块）都会在初始化阶段前置加载，影响首屏性能；</li><li>import()能够在函数、分支等非顶层作用域使用，按需加载、懒加载都不是问题。</li><li>动态导入import(),返回的是promise对象；</li><li>import.mate:mate属性，表示路径关系</li><li>export * as obj from “xx.js”:复制别人的方法，无损方式继承</li></ul></li><li><p>String.prototype.matchAll()：matchAll()返回的迭代器不仅包括精确的匹配结果，还有全部的正则模式捕获结果</p></li><li><p>BigInt</p><ul><li>JS 中的Number类型只能安全地表示-9007199254740991 (-(2^53-1)) 和9007199254740991(2^53-1)之间的整数，任何超出此范围的整数值都可能失去精度。</li><li>要创建一个 bigint，可以在一个整数的末尾添加字符n，或者调用函数 BigInt()。BigInt 函数使用字符串、数字等来创建一个BigInt。</li><li>eg:<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-number">9007199254740992</span> === <span class="hljs-number">9007199254740993</span>;<span class="hljs-comment">//true</span><br><span class="hljs-number">9007199254740992n</span> === <span class="hljs-number">9007199254740993n</span>; <span class="hljs-comment">//false</span><br></code></pre></td></tr></table></figure></li></ul></li><li><p>globalThis:在浏览器中它是 window, 在 Node.js 中它是global。</p></li><li><p>??:空值合并运算符：它与或“||”区别：值为0时，??的左侧依然为“0”，而或“||”左侧则会被转换成布尔false从而选择右侧的值</p></li><li><p>?.：可选链。用户检测不确定的中间节点，如果不存在中间节点则返回undefined。</p></li></ul><h2 id="ES12"><a href="#ES12" class="headerlink" title="ES12"></a>ES12</h2><ul><li>??&#x3D;,&amp;&amp;&#x3D;,||&#x3D;<ul><li>??&#x3D;:逻辑合并赋值</li><li>&amp;&amp;&#x3D;:逻辑与赋值</li><li>||&#x3D;:逻辑或赋值</li></ul></li><li>String.prototype.replaceAll():eg:str.replaceAll(replace,newValue)</li><li>Promise.any(iterable):返回第一个 fulfilled 的 promise ，若全部 reject，则返回一个带有失败原因的 AggregateError实例<ul><li>只要有一个兑现就可以了，特别是多设备部署同接口，多备份的优势就能体现出来了；</li><li>eg:三者只要有一个能请求成功就ok<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">any</span>([pErr, pSlow, pFast]).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(value);<br>&#125;)<br></code></pre></td></tr></table></figure></li></ul></li><li>WeakRef()&#x2F;WeakSet()&#x2F;weak series：WeakRef 对象包含对对象的弱引用，能不使用就尽量不要使用（表现达不到预取，而且在不同JavaScript引擎中效果千差万别）</li><li>FinalizationRegistry()：FinalizationRegistry 对象可以让你在对象被垃圾回收时请求一个回调。<ul><li>eg:<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> registry = <span class="hljs-keyword">new</span> <span class="hljs-title class_">FinalizationRegistry</span>(<span class="hljs-function"><span class="hljs-params">heldValue</span> =&gt;</span> &#123;&#125;);<br>registry.<span class="hljs-title function_">register</span>(theObject, <span class="hljs-string">&quot;some value&quot;</span>);<br></code></pre></td></tr></table></figure></li></ul></li><li>_:数字分割符:<code>const num=1_000_000_000</code></li></ul><h2 id="ES13"><a href="#ES13" class="headerlink" title="ES13"></a>ES13</h2><ul><li>class extend<ul><li>支持私有：#</li><li>static：静态</li><li>静态代码块</li><li>用in判断对象方法是否为函数的私有属性和方法</li></ul></li><li>await：全局await,不建议这么用，可能会阻塞js进程导致变慢</li><li>at():索引元素；egg:arr.at(num),num可以为正负数</li><li>Object.hasOwn():用来检测对象中是否含有指定属性，它接受对象和属性作为参数，返回 true&#x2F;false。</li><li>regex:正则匹配的开始和结束索引；eg:<code>reg=/xxx/d</code><ul><li>eg:<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> str = <span class="hljs-string">&quot;今天是2023-04-12&quot;</span><br><span class="hljs-keyword">let</span> reg = <span class="hljs-regexp">/(?&lt;year&gt;\d&#123;4&#125;)-(?&lt;month&gt;\d&#123;2&#125;)-(?&lt;day&gt;\d&#123;2&#125;)/</span>d<br><span class="hljs-keyword">let</span> res = reg.<span class="hljs-title function_">exec</span>(str)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res);<br><span class="hljs-comment">// [&#x27;2023-04-12&#x27;, &#x27;2023&#x27;, &#x27;04&#x27;, &#x27;12&#x27;, index: 3, input: &#x27;今天是2023-04-12&#x27;, groups: &#123;…&#125;, indices: Array(4)]</span><br></code></pre></td></tr></table></figure></li></ul></li><li>Array.prototype.findLast()&#x2F;findLastIndex():快速查找到符合条件的最后一项或者下标。</li><li>Error object cause property:Error对象cause属性即错误描述。<ul><li>eg:<code>new Error(&quot;new error message&quot;,&#123;cause:err&#125;)</code></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ECMAScript</tag>
      
      <tag>ES6</tag>
      
      <tag>ES13</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
